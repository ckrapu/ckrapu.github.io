<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Fast Kronecker matrix-vector product with einsum | Christopher Krapu </title> <meta name="author" content="Christopher Krapu"> <meta name="description" content="Easy local average with Google Earth Engine's Python API"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%81&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ckrapu.github.io/blog/2021/fast-matrix-vector-product-for-structured-matrices/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Christopher</span> Krapu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">posts </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"> search <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Fast Kronecker matrix-vector product with einsum</h1> <p class="post-meta"> Created in November 28, 2021 </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In numerical linear algebra, a common problem that arises in the analysis of large datasets is the product of a dense but structured \(N \times N\) matrix \(\mathbf{A} = \bigotimes_{j=1}^J \mathbf{A}_j\) with a similarly dense vector \(\mathbf{y}\). We’re assuming that \(\mathbf{A}\) can be written as the tensor or Kronecker product of \(J\) smaller matrices denoted by \(\mathbf{A}_j\), each of which has dimension \(N_j\).</p> <p>Our strategy in computing this is to rearrange \(\mathbf{y}\) into a multdimensional array and, by contracting indices in an efficient way, avoid an \(\mathcal{O}(N^2)\) matrix-vector operation. Some of the commonly used identities of product matrices are available on <a href="https://en.wikipedia.org/wiki/Kronecker_product" rel="external nofollow noopener" target="_blank">Wikipedia</a>, and we’ll make use of several of them. We let \(\mathbf{Y}\) denote an array formed from the vector \(\mathbf{y}\) by reshaping into a form with axis dimensions of \(N_1,...,N_J\). By the associative property of the tensor product, \(\begin{align} \left(\bigotimes_{j=1}^J \mathbf{A}_j \right) \mathbf{y}&amp;=\mathbf{A}_1\otimes\left(\cdot\cdot\cdot\otimes(\mathbf{A}_J\mathbf{Y})\right)\\ &amp;=u^{(1)}_{k_1,k_2}u^{(2)}_{k_3,k_4}\cdot\cdot\cdot u^{(J)}_{k_{2J-1},k_{2J}}Y_{k_2,k_4,...,k_{2J}} \end{align}\) where we let \(u^{(1)}_{k_1k_2}\) refer to the entry of the \(k_1\)-th row and \(k_2\)-th column of \(\mathbf{A}_1\). The second equation above uses <a href="https://en.wikipedia.org/wiki/Einstein_notation" rel="external nofollow noopener" target="_blank">Einstein notation</a> in representing the tensor product and multidimensional array \(\mathbf{Y}\). The \(k\) indices look a little funky compared to usual tensor notation; in physics we are used to having actual letters such as \(i, j, k\) rather than letters with numbers. However, if we have an arbitrary number of Kronecker factors, there may be many, many indices used, so we avoid using any particular letter and instead replace \(i, j, k, l, m,...\) with \(k_1, k_2, k_3, k_4, k_5,...\).</p> <p>The rule for Einstein notation is that when an index appears twice, we sum over it, also described as “contraction” over that index. Contracting the repeated indices, the result of the above procedure is an array \(\mathbf{Z}\) of the same dimensions as \(\mathbf{Y}\) running over indices \(k_1, k_3,...,k_{2J-1}\) which has been transformed by the repeated application of the matrix and tensor product operations and which satisfies the equality \(Vec(\mathbf{Z})=\left(\bigotimes_{j=1}^J \mathbf{A}_j \right) \mathbf{y}\). Since each of the \(J\) tensor contractions involves a sum involving \(N_j\) terms, each of which makes use of all \(N\) elements in \(\mathbf{Y}\), the overall complexity of this algorithm is \(\mathcal{O}(N \cdot \sum_{j=1}^J N_j)\), which compares favorably with the naive \(\mathcal{O}(N^2)\).</p> <p>This entire procedure can be run in a single call to the <code class="language-plaintext highlighter-rouge">einsum</code> function available in Numpy.</p> <p>Here, I should note that this is essentially the same result characterized by <a href="http://mlg.eng.cam.ac.uk/pub/pdf/Saa11.pdf" rel="external nofollow noopener" target="_blank">Saatchi’s PhD</a> thesis, but this presentation omits the dependence upon permutation indices and transpositions that obscures the essential index operations involved. Alex Williams has an <a href="https://gist.github.com/ahwillia/f65bc70cb30206d4eadec857b98c4065" rel="external nofollow noopener" target="_blank">implementation</a> of this calculation in PyTorch, but it does the index juggling by hand and is a bit more complex than automatically contracting the right indices. In the rest of this notebook, I show how to implement this operation in a few lines of Python.</p> <h3 id="implementing-an-efficient-matrix-vector-product">Implementing an efficient matrix-vector product</h3> <p>To begin, we’ll cook up a set of 5 square, symmetric matrices of increasing size. We’ll guarantee they are symmetic and positive semidefinite by squaring them.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">sizes</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span>
<span class="n">prod_size</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">prod</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>

<span class="n">matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]</span>
<span class="n">matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="nd">@X.T</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>


</code></pre></div></div> <p>In the end, we want to take the Kronecker / tensor product of these matrices. Since they have increasing dimension, the dimension of their Kronecker product will be <code class="language-plaintext highlighter-rouge">3*4*5*6*7=2520</code></p> <p>To see what the Kronecker product looks like, let’s see what the product of two of these matrices looks like:</p> <p><img src="/images/kron_im.png" alt="png" style="width:50%;"></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">A</span><span class="p">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(3, 3), (4, 4), (5, 5), (6, 6), (7, 7)]
</code></pre></div></div> <p>As promised, these matrices are invertible as shown by their determinants. Since each of these determinants is nonzero, an inverse exists.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[19.055143537578502,
 0.041852313010475074,
 0.008158197604522445,
 43.252474950990084,
 798.5649833818011]
</code></pre></div></div> <p>We will also instantiate the vector \(\mathbf{y}\), though here we create it in the array form and then vectorize it later.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="o">*</span><span class="n">sizes</span><span class="p">)</span>
</code></pre></div></div> <p>Here, we perform a brute-force calculation of the matrix-vector product by instantiating the full Kronecker product. We do this by iteratively applying the Kronecker product to each of the matrices.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="n">big_matrix</span> <span class="o">=</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">matrices</span><span class="p">)</span>
<span class="n">matrix_product</span> <span class="o">=</span> <span class="n">big_matrix</span> <span class="o">@</span> <span class="n">y</span><span class="p">.</span><span class="nf">ravel</span><span class="p">()</span>
</code></pre></div></div> <p>We’ll also do the same using the <code class="language-plaintext highlighter-rouge">einsum</code> function. The first argument is a string specification for the tensor contraction. Essentially, it is saying that we have 5 two-dimensional arrays (with indices <code class="language-plaintext highlighter-rouge">ij</code>, <code class="language-plaintext highlighter-rouge">kl</code>, and so on), and that they are multiplied with a 5-dimensional array to output another 5-dimensional array.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tensors</span> <span class="o">=</span> <span class="n">matrices</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
<span class="n">einstein_product</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">'</span><span class="s">ij,kl,mn,op,qr,ikmoq-&gt;jlnpr</span><span class="sh">'</span><span class="p">,</span> <span class="o">*</span><span class="n">tensors</span><span class="p">)</span>

</code></pre></div></div> <p>Both procedures result in the same values! Note that if you use the elementwise <code class="language-plaintext highlighter-rouge">==</code> operator overloaded by Numpy, you will get <code class="language-plaintext highlighter-rouge">False</code> due to minor differences due to the floating point representation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">matrix_product</span><span class="p">,</span> <span class="n">einstein_product</span><span class="p">.</span><span class="nf">ravel</span><span class="p">())</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div> <p>The next code cell packages up these functions so we can reuse them later to assess the relative runtimes of each.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">string</span> <span class="kn">import</span> <span class="n">ascii_lowercase</span> <span class="k">as</span> <span class="n">letters</span>

<span class="k">def</span> <span class="nf">mv_kron</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Compute product of vector and Kronecker-structured matrix
    via brute-force enumeration of entire Kronecker matrix.
    </span><span class="sh">'''</span>
    <span class="n">A_kron</span> <span class="o">=</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">kron</span><span class="p">,</span> <span class="n">matrices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_kron</span> <span class="o">@</span> <span class="n">y</span><span class="p">.</span><span class="nf">ravel</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">mv_einstein</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Use Einstein summation convention to iteratively
    contract along secondary axes and implement Kronecker 
    matrix-vector product
    </span><span class="sh">'''</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">13</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">There aren</span><span class="se">\'</span><span class="s">t enough letters in the alphabet for this operation :(</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="n">letter_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">letters</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">letters</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="n">matrix_string</span> <span class="o">=</span> <span class="sh">'</span><span class="s">,</span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">letter_pairs</span><span class="p">)</span>
    <span class="n">vec_in_string</span><span class="p">,</span> <span class="n">vec_out_string</span> <span class="o">=</span> <span class="p">[</span><span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">letter_pairs</span><span class="p">)]</span>
    <span class="n">string_spec</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">matrix_string</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">vec_in_string</span><span class="si">}</span><span class="s">-&gt;</span><span class="si">{</span><span class="n">vec_out_string</span><span class="si">}</span><span class="sh">'</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="n">string_spec</span><span class="p">,</span> <span class="o">*</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="sh">'</span><span class="s">greedy</span><span class="sh">'</span><span class="p">).</span><span class="nf">ravel</span><span class="p">(),</span> <span class="n">string_spec</span>
</code></pre></div></div> <h3 id="comparing-runtimes">Comparing runtimes</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ein_times</span>  <span class="o">=</span> <span class="p">[]</span>
<span class="n">kron_times</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">dimensions</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]:</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">scale</span><span class="p">]</span>
    <span class="n">matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">]</span>
    <span class="n">matrices</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="nd">@X.T</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="o">*</span><span class="n">sizes</span><span class="p">)</span>
    
    <span class="n">start_kron</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
    <span class="nf">mv_kron</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">end_kron</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_kron</span>
    
    <span class="n">start_ein</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">string_spec</span> <span class="o">=</span> <span class="nf">mv_einstein</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">end_ein</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_ein</span>
    
    <span class="n">ein_times</span>  <span class="o">+=</span> <span class="p">[</span><span class="n">end_ein</span><span class="p">]</span>
    <span class="n">kron_times</span> <span class="o">+=</span> <span class="p">[</span><span class="n">end_kron</span><span class="p">]</span>
    <span class="n">dimensions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Dimension:</span><span class="sh">'</span><span class="p">,</span> <span class="nf">str</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">).</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Einstein time: </span><span class="si">{</span><span class="n">end_ein</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s"> s.</span><span class="sh">'</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">Naive time </span><span class="si">{</span><span class="n">end_kron</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="s">s.</span><span class="sh">'</span><span class="p">)</span>


</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dimension: 64    Einstein time: 0.001 s. Naive time 0.001s.
Dimension: 512   Einstein time: 0.000 s. Naive time 0.016s.
Dimension: 1728  Einstein time: 0.000 s. Naive time 0.039s.
Dimension: 4096  Einstein time: 0.000 s. Naive time 0.190s.
Dimension: 8000  Einstein time: 0.001 s. Naive time 0.921s.
Dimension: 13824 Einstein time: 0.001 s. Naive time 2.632s.
Dimension: 21952 Einstein time: 0.018 s. Naive time 7.073s.
Dimension: 32768 Einstein time: 0.063 s. Naive time 95.083s.
</code></pre></div></div> <p>As we can see below, there’s a big disparity in runtime, although I can’t really probe any larger dimension sizes since my laptop has a small amount of memory.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">ein_times</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Einstein</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">kron_times</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="sh">'</span><span class="s">d</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">m</span><span class="sh">'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Naive</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">yscale</span><span class="p">(</span><span class="sh">'</span><span class="s">log</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">$\log_{10}$ runtime</span><span class="sh">'</span><span class="p">),</span> <span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">$N$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">savefig</span><span class="p">(</span><span class="sh">'</span><span class="s">../figures/kmvp_runtime.png</span><span class="sh">'</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">();</span>

</code></pre></div></div> <p><img src="/images/kmvp_runtime.png" alt="png" style="width:75%;"></p> <p>Finally, it’s interesting to note that behind-the-scenes, the Numpy implementation of <code class="language-plaintext highlighter-rouge">einsum</code> is performing a <em>path optimization</em> to determine which indices should be contracted first. We can check it out by calling <code class="language-plaintext highlighter-rouge">einsum_path</code> and examining the results.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="nf">einsum_path</span><span class="p">(</span><span class="n">string_spec</span><span class="p">,</span> <span class="o">*</span><span class="n">matrices</span><span class="p">,</span> <span class="n">y</span><span class="p">)];</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['einsum_path', (2, 3), (1, 2), (0, 1)]
  Complete contraction:  ab,cd,ef,ace-&gt;bdf
         Naive scaling:  6
     Optimized scaling:  4
      Naive FLOP count:  4.295e+09
  Optimized FLOP count:  7.340e+06
   Theoretical speedup:  585.143
  Largest intermediate:  3.277e+04 elements
--------------------------------------------------------------------------
scaling                  current                                remaining
--------------------------------------------------------------------------
   4                 ace,ef-&gt;acf                           ab,cd,acf-&gt;bdf
   4                 acf,cd-&gt;adf                              ab,adf-&gt;bdf
   4                 adf,ab-&gt;bdf                                 bdf-&gt;bdf
</code></pre></div></div> <p>This printout tells us two things: first, the number of floating point operations is nearly 600X smaller for the optimized summation path. Second, the largest array held in memory is only on the order of \(10^4\) elements, so it’s much more memory efficient.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/balanced-spatial-partitioning-for-point-data-in-20-lines/">Balanced spatial partitioning for point data in 20 lines</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/clustering-for-prob-preterm-birth/">Modeling spatial structure in binary data with an H3 hexagonal coordinate system</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/fast-local-summary-earth-engine/">Distributed zonal averages for fast geospatial analyses</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/nonparametric-changepoint-model-pymc/">Modeling temporal data with an unknown number of changepoints</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/density-estimation-for-geospatial-imagery-using-autoregressive-models/">Density estimation for geospatial imagery using autoregressive neural models</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Christopher Krapu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-rjmgmaB99riUNcdlrDtcAiwtLIojSxNyUFdl+Qh+rB4=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let theme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===theme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=document.querySelector(".navbar-collapse");e.classList.contains("show")&&e.classList.remove("show"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-posts",title:"posts",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-modeling-temporal-data-with-an-unknown-number-of-changepoints",title:"Modeling temporal data with an unknown number of changepoints",description:"A nonparametric changepoint model in PyMC",section:"Posts",handler:()=>{window.location.href="/blog/2022/nonparametric-changepoint-model-pymc/"}},{id:"post-distributed-zonal-averages-for-fast-geospatial-analyses",title:"Distributed zonal averages for fast geospatial analyses",description:"Easy local average with Google Earth Engine&#39;s Python API",section:"Posts",handler:()=>{window.location.href="/blog/2022/fast-local-summary-earth-engine/"}},{id:"post-fast-kronecker-matrix-vector-product-with-einsum",title:"Fast Kronecker matrix-vector product with einsum",description:"Easy local average with Google Earth Engine&#39;s Python API",section:"Posts",handler:()=>{window.location.href="/blog/2021/fast-matrix-vector-product-for-structured-matrices/"}},{id:"post-balanced-spatial-partitioning-for-point-data-in-20-lines",title:"Balanced spatial partitioning for point data in 20 lines",description:"Recursively splitting by boxes",section:"Posts",handler:()=>{window.location.href="/blog/2021/balanced-spatial-partitioning-for-point-data-in-20-lines/"}},{id:"post-modeling-spatial-structure-in-binary-data-with-an-h3-hexagonal-coordinate-system",title:"Modeling spatial structure in binary data with an H3 hexagonal coordinate system",description:"Conditional autoregression for 6-adjacent data",section:"Posts",handler:()=>{window.location.href="/blog/2021/clustering-for-prob-preterm-birth/"}},{id:"post-surrogate-modeling-for-seir-dynamics",title:"Surrogate modeling for SEIR dynamics",description:"Modeling a model, for epidemiology",section:"Posts",handler:()=>{window.location.href="/blog/2021/creating-an-emulator-for-an-agent-based-model/"}},{id:"post-density-estimation-for-geospatial-imagery-using-autoregressive-neural-models",title:"Density estimation for geospatial imagery using autoregressive neural models",description:"Conditional autoregression for 6-adjacent data",section:"Posts",handler:()=>{window.location.href="/blog/2020/density-estimation-for-geospatial-imagery-using-autoregressive-models/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%63%6B%72%61%70%75@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/ckrapu","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> </body> </html>