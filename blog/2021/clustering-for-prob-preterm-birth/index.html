<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Modeling spatial structure in binary data with an H3 hexagonal coordinate system | Christopher Krapu </title> <meta name="author" content="Christopher Krapu"> <meta name="description" content="Conditional autoregression for 6-adjacent data"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%81&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ckrapu.github.io/blog/2021/clustering-for-prob-preterm-birth/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Christopher</span> Krapu </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">posts </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"> search <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Modeling spatial structure in binary data with an H3 hexagonal coordinate system</h1> <p class="post-meta"> Created in April 29, 2021 </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>We often model geostatistical (i.e. point-referenced data) in order to determine whether or not there are spatial patterns of autocorrelation. The object of interest is frequently an underlying spatial function giving rise to patterns of spatially correlated data. When we work with discrete observational data, a problem arises - we want to study smoothly-varying response surfaces over space, but the data themselves are not continuous and therefore we cannot specify a likelihood which is continuous in both space and response. Consequently, we often choose to <strong>reparameterize</strong> our model in terms of a latent smooth spatial surface and a link function mapping this spatial surface to the parameters of a likelihood function appropriate for discrete data.</p> <p>This notebook shows how to analyze binary geospatial point data using a spatially-smoothing conditional autoregression model to test for the existence of clusters of 0 or 1 values. The dataset used in this example is <strong>simulated</strong> data of preterm births in Washington, DC. While many autoregressive models use square grids, we’re going to use a hexagonal tiling from Uber’s H3 coordinate system library to demarcate our areal units.</p> <h2 id="generating-simulated-data">Generating simulated data</h2> <p>We begin by importing the requisite libraries and simulating synthetic data of preterm births.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">geopandas</span> <span class="k">as</span> <span class="n">gpd</span>
<span class="kn">import</span> <span class="n">h3</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">pymc3</span> <span class="k">as</span> <span class="n">pm</span>
<span class="kn">import</span> <span class="n">shapely</span>

<span class="kn">from</span> <span class="n">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">BallTree</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="o">%</span><span class="n">config</span> <span class="n">InlineBackend</span><span class="p">.</span><span class="n">figure_format</span><span class="o">=</span><span class="sh">'</span><span class="s">retina</span><span class="sh">'</span>
</code></pre></div></div> <p>To ensure reproducibility, it’s a good habit to include a version stamp as shown below.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">load_ext</span> <span class="n">watermark</span>
<span class="o">%</span><span class="n">watermark</span> <span class="o">-</span><span class="n">iv</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The watermark extension is already loaded. To reload it, use:
  %reload_ext watermark
h3        : 3.7.2
pymc3     : 3.11.1
shapely   : 1.7.1
geopandas : 0.8.1
numpy     : 1.18.5
pandas    : 1.1.3
matplotlib: 3.3.2
networkx  : 2.5
</code></pre></div></div> <p>At several points we will need to use multiple functions to handle geospatial operations such as creating point data, determining the adjacency of vector features, and ensuring that sets of spatial objects are topologically connected. We’ll define them now so we can use them later.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">xy_from_gdf</span><span class="p">(</span><span class="n">gdf</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Returns Nx2 matrix of X,Y coordinates from a GeoDataFrame
    </span><span class="sh">'''</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">gdf</span><span class="p">.</span><span class="n">centroid</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">gdf</span><span class="p">.</span><span class="n">centroid</span><span class="p">.</span><span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lat_lng_to_h3</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">h3_level</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Applies H3</span><span class="sh">'</span><span class="s">s geocoding to determine the hexagonal cell
    containing a given point. The h3 level determines the
    size of the hexagonal lattice used.
    </span><span class="sh">'''</span>
    <span class="k">return</span> <span class="n">h3</span><span class="p">.</span><span class="nf">geo_to_h3</span><span class="p">(</span>
      <span class="n">point</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">centroid</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="n">centroid</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">h3_level</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_geometry</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Creates a vector feature from the H3 hexagonal coordinates.
    </span><span class="sh">'''</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">h3</span><span class="p">.</span><span class="nf">h3_to_geo_boundary</span><span class="p">(</span>
      <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shapely</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nc">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nearest_neighbor_centroid</span><span class="p">(</span><span class="n">gdf1</span><span class="p">,</span> <span class="n">gdf2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Vectorized operation for identifying the nearest points in gdf2 relative to gdf1.
    </span><span class="sh">'''</span>
    <span class="n">X_proposed</span><span class="p">,</span> <span class="n">X_base</span> <span class="o">=</span> <span class="nf">xy_from_gdf</span><span class="p">(</span><span class="n">gdf1</span><span class="p">),</span> <span class="nf">xy_from_gdf</span><span class="p">(</span><span class="n">gdf2</span><span class="p">)</span>        
    <span class="n">nearest</span> <span class="o">=</span> <span class="nc">BallTree</span><span class="p">(</span><span class="n">X_proposed</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">2</span><span class="p">).</span><span class="nf">query</span><span class="p">(</span><span class="n">X_base</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nearest</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">adjacency_via_buffer</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">very_small_distance</span><span class="o">=</span><span class="mf">0.0003</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Uses a spatial buffering and intersection operator to determine
    which features share a boundary in a GeoDataFrame.
    </span><span class="sh">'''</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">buffered</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
    <span class="n">buffered</span><span class="p">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">buffered</span><span class="p">.</span><span class="nf">buffer</span><span class="p">(</span><span class="n">very_small_distance</span><span class="p">)</span>

    <span class="c1"># Find neighbors by buffering and locating non-null overlap
</span>    <span class="n">nearby</span>  <span class="o">=</span> <span class="n">buffered</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">buffered</span><span class="p">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="nf">nearest_neighbor_centroid</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">nearby</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>          <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># self-neighboring is not allowed
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">nearest</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">+</span><span class="n">W</span><span class="p">.</span><span class="n">T</span> <span class="o">&gt;</span> <span class="mf">0.</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span>

<span class="k">def</span> <span class="nf">connect_components</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">geom_series</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Iteratively add edges between nodes to the network
    until only a single edge-connected component covers the entire graph. This
    is critical for usage of the CAR model, which can fail if there
    are </span><span class="sh">"</span><span class="s">islands</span><span class="sh">"</span><span class="s"> disconnected from each other in the network / adjacency matrix.
    </span><span class="sh">'''</span>
    <span class="n">connected</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">connected</span><span class="p">:</span>

        <span class="c1"># Find the largest component and drop it from
</span>        <span class="c1"># the list of islands
</span>        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">convert_matrix</span><span class="p">.</span><span class="nf">from_numpy_matrix</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">nx</span><span class="p">.</span><span class="nf">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="k">break</span>
            
        <span class="n">components</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">nx</span><span class="p">.</span><span class="nf">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
        <span class="n">sizes</span>      <span class="o">=</span> <span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>
        <span class="n">largest</span>    <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span>
        <span class="n">components</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>

        <span class="c1"># For each island, find the nearest node not on
</span>        <span class="c1"># the island and hook it up
</span>        <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">element_on_island</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">island</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">geom_on_island</span>    <span class="o">=</span> <span class="n">geom_series</span><span class="p">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">element_on_island</span><span class="p">]]</span>
            <span class="n">repeated</span>  <span class="o">=</span> <span class="n">geom_on_island</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">geom_series</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">geom_series</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">geom_on_island</span><span class="p">.</span><span class="nf">distance</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">ordered_by_dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">.</span><span class="n">values</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">connected_for_island</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">connected_for_island</span><span class="p">:</span>
                <span class="n">proposed</span> <span class="o">=</span> <span class="n">ordered_by_dist</span><span class="p">[</span><span class="n">ctr</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">proposed</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">island</span><span class="p">:</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">element_on_island</span><span class="p">,</span> <span class="n">proposed</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">W</span><span class="p">[</span><span class="n">proposed</span><span class="p">,</span> <span class="n">element_on_island</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Match for element {0} is {1}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">element_on_island</span><span class="p">,</span> <span class="n">proposed</span><span class="p">))</span>
                    <span class="n">connected_for_island</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">ctr</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">convert_matrix</span><span class="p">.</span><span class="nf">from_numpy_matrix</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="n">connected</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nf">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">W</span>

</code></pre></div></div> <p>Next, we use a shapefile of census tract data to determine how to sample birth events over space. We will use the population within each census tract, combined with a national average birth rate to determine how many births will be placed within each tract.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">'''</span><span class="s">
Census tract shapefile taken from https://opendata.arcgis.com/datasets/f33d847161174e81ad59c9ea9c1f5a00_36.zip
</span><span class="sh">'''</span>
<span class="n">census_tract_path</span> <span class="o">=</span> <span class="sh">"</span><span class="s">./data/Preliminary_2020_Census_Tract/Preliminary_2020_Census_Tract.shp</span><span class="sh">"</span>
<span class="n">tract_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="p">.</span><span class="nf">read_file</span><span class="p">(</span><span class="n">census_tract_path</span><span class="p">)</span>

</code></pre></div></div> <p>As we can see here, the <code class="language-plaintext highlighter-rouge">POP10</code> field contains census counts.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tract_gdf</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>OBJECTID</th> <th>STATEFP</th> <th>COUNTYFP</th> <th>TRACTCE</th> <th>NAME</th> <th>TRACTID</th> <th>TRACTLABEL</th> <th>POP10</th> <th>HOUSING10</th> <th>SHAPEAREA</th> <th>SHAPELEN</th> <th>geometry</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>21</td> <td>11</td> <td>001</td> <td>001301</td> <td>13.01</td> <td>11001001301</td> <td>13.01</td> <td>3955</td> <td>2156</td> <td>2.882225e+06</td> <td>8705.698378</td> <td>POLYGON ((-77.06943 38.95434, -77.06932 38.954...</td> </tr> <tr> <th>1</th> <td>22</td> <td>11</td> <td>001</td> <td>002001</td> <td>20.01</td> <td>11001002001</td> <td>20.01</td> <td>2340</td> <td>1026</td> <td>6.337953e+05</td> <td>4198.601803</td> <td>POLYGON ((-77.04338 38.96146, -77.04329 38.961...</td> </tr> <tr> <th>2</th> <td>23</td> <td>11</td> <td>001</td> <td>003302</td> <td>33.02</td> <td>11001003302</td> <td>33.02</td> <td>2134</td> <td>982</td> <td>2.042153e+05</td> <td>1915.794576</td> <td>POLYGON ((-77.01428 38.91506, -77.01275 38.915...</td> </tr> <tr> <th>3</th> <td>24</td> <td>11</td> <td>001</td> <td>008402</td> <td>84.02</td> <td>11001008402</td> <td>84.02</td> <td>2149</td> <td>1270</td> <td>2.741538e+05</td> <td>2698.287213</td> <td>POLYGON ((-76.99497 38.89741, -76.99496 38.898...</td> </tr> <tr> <th>4</th> <td>1</td> <td>11</td> <td>001</td> <td>000101</td> <td>1.01</td> <td>11001000101</td> <td>1.01</td> <td>1384</td> <td>999</td> <td>1.993245e+05</td> <td>2168.618432</td> <td>POLYGON ((-77.05714 38.91055, -77.05702 38.910...</td> </tr> </tbody> </table> </div> <p>Our next step is to create a data table in which each row corresponds to a birth event and is associated with geospatial coordinates as well as a year.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">base_pregnancy_rate</span> <span class="o">=</span> <span class="mf">11.4</span> <span class="o">/</span> <span class="mi">1000</span> <span class="c1"># births per thousand people
</span><span class="n">years</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">2019</span><span class="p">)</span>

<span class="n">birth_coords</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">birth_points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">year</span> <span class="ow">in</span> <span class="n">years</span><span class="p">:</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tract</span> <span class="ow">in</span> <span class="n">tract_gdf</span><span class="p">.</span><span class="nf">iterrows</span><span class="p">():</span>
        <span class="n">tract_boundary</span> <span class="o">=</span> <span class="n">tract</span><span class="p">.</span><span class="n">geometry</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">tract_boundary</span><span class="p">.</span><span class="n">bounds</span>
        <span class="n">n_pregnancies</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">base_pregnancy_rate</span> <span class="o">*</span> <span class="n">tract</span><span class="p">[</span><span class="sh">'</span><span class="s">POP10</span><span class="sh">'</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_pregnancies</span><span class="p">):</span>
            <span class="n">is_in_bounds</span> <span class="o">=</span> <span class="bp">False</span>
            
            <span class="k">while</span> <span class="ow">not</span> <span class="n">is_in_bounds</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="p">[</span><span class="n">left</span><span class="p">,</span><span class="n">lower</span><span class="p">],</span><span class="n">high</span><span class="o">=</span><span class="p">[</span><span class="n">right</span><span class="p">,</span><span class="n">upper</span><span class="p">])</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">shapely</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nc">Point</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                <span class="n">is_in_bounds</span> <span class="o">=</span> <span class="n">tract</span><span class="p">.</span><span class="n">geometry</span><span class="p">.</span><span class="nf">contains</span><span class="p">((</span><span class="n">sample</span><span class="p">))</span>
                
            <span class="n">birth_points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
            <span class="n">birth_coords</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="n">year</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">()])</span>
                     
<span class="n">birth_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="p">.</span><span class="nc">GeoDataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">birth_coords</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">lat</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">lon</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">year</span><span class="sh">'</span><span class="p">],</span> <span class="n">geometry</span><span class="o">=</span><span class="n">birth_points</span><span class="p">)</span>
<span class="n">birth_gdf</span><span class="p">[</span><span class="sh">"</span><span class="s">year_int</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">birth_gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">year</span><span class="sh">'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">birth_gdf</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <div> <style scoped="">.dataframe tbody tr th:only-of-type{vertical-align:middle}.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</style> <table border="1" class="dataframe"> <thead> <tr style="text-align: right;"> <th></th> <th>lat</th> <th>lon</th> <th>year</th> <th>geometry</th> <th>year_int</th> </tr> </thead> <tbody> <tr> <th>0</th> <td>-77.062823</td> <td>38.951295</td> <td>2010.816216</td> <td>POINT (-77.06282 38.95130)</td> <td>2010</td> </tr> <tr> <th>1</th> <td>-77.056945</td> <td>38.949016</td> <td>2010.555112</td> <td>POINT (-77.05695 38.94902)</td> <td>2010</td> </tr> <tr> <th>2</th> <td>-77.066707</td> <td>38.951606</td> <td>2010.082630</td> <td>POINT (-77.06671 38.95161)</td> <td>2010</td> </tr> <tr> <th>3</th> <td>-77.062031</td> <td>38.951623</td> <td>2010.639241</td> <td>POINT (-77.06203 38.95162)</td> <td>2010</td> </tr> <tr> <th>4</th> <td>-77.064879</td> <td>38.955598</td> <td>2010.950265</td> <td>POINT (-77.06488 38.95560)</td> <td>2010</td> </tr> </tbody> </table> </div> <p>To make this problem more interesting, we’ll simulate preterm births with spatial dependency. Our true generative process will allow for more preterm births in locations which are farther to the east and north.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">birth_df</span>   <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">birth_gdf</span><span class="p">).</span><span class="nf">drop</span><span class="p">([</span><span class="sh">'</span><span class="s">geometry</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">year_int</span><span class="sh">'</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">scales</span>     <span class="o">=</span> <span class="n">birth_df</span><span class="p">.</span><span class="nf">std</span><span class="p">()</span>
<span class="n">means</span>      <span class="o">=</span>  <span class="n">birth_df</span><span class="p">.</span><span class="nf">mean</span><span class="p">()</span>
<span class="n">zscore_gdf</span> <span class="o">=</span> <span class="p">(</span><span class="n">birth_df</span> <span class="o">-</span><span class="n">means</span><span class="p">)</span><span class="o">/</span><span class="n">scales</span>

<span class="c1"># coefs are for lat, lon, and year respectively.
</span><span class="n">true_coefficients</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

<span class="c1"># this value was chosen by hand to roughly line up with ~12% preterm births, on average
</span><span class="n">true_intercept</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="n">logits</span> <span class="o">=</span> <span class="n">zscore_gdf</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">true_coefficients</span><span class="p">)</span><span class="o">+</span><span class="n">true_intercept</span>

<span class="n">birth_gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">preterm_prob</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>

<span class="n">birth_gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">preterm</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">birth_gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">preterm_prob</span><span class="sh">'</span><span class="p">])</span>
<span class="n">birth_gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">preterm</span><span class="sh">'</span><span class="p">].</span><span class="nf">mean</span><span class="p">()</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.12306756134464839
</code></pre></div></div> <p>Let’s see the spatial point pattern for the births. The preterm births are marked in red while normal births are marked with blue points.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">.</span><span class="nf">ravel</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">year</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">years</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]):</span>
    <span class="n">birth_gdf</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">year_int==</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s"> &amp; preterm==1</span><span class="sh">"</span><span class="p">).</span><span class="nf">plot</span><span class="p">(</span><span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                            <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">birth_gdf</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">year_int==</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="s"> &amp; preterm==0</span><span class="sh">"</span><span class="p">).</span><span class="nf">plot</span><span class="p">(</span><span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                            <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">blue</span><span class="sh">'</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    
    <span class="n">tract_gdf</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">facecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">preterm_frac</span> <span class="o">=</span> <span class="n">birth_gdf</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">year_int==</span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="sh">"</span><span class="p">)[</span><span class="sh">'</span><span class="s">preterm</span><span class="sh">'</span><span class="p">].</span><span class="nf">mean</span><span class="p">()</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Simulated births for </span><span class="si">{</span><span class="n">year</span><span class="si">}</span><span class="se">\n</span><span class="s">(Preterm fraction: </span><span class="si">{</span><span class="nf">int</span><span class="p">(</span><span class="n">preterm_frac</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="si">}</span><span class="s">%)</span><span class="sh">'</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">axis</span><span class="p">(</span><span class="sh">'</span><span class="s">off</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>

</code></pre></div></div> <p><img src="/images/preterm20_0.png" alt="png" style="width:75%;"></p> <p>A flaw of this simulation is that there are clearly jumps in point density at the interface between high- and low-population census tracts which are not reflective of reality.</p> <h2 id="preprocessing-spatial-adjacency-data">Preprocessing spatial adjacency data</h2> <p>Since we don’t want to construct our model directly at the point level, we instead need to aggregate to a larger spatial unit. For this purpose, we’ll use the <code class="language-plaintext highlighter-rouge">h3</code> library to aggregate into hexagonal bins.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h3_level</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">gdf</span> <span class="o">=</span> <span class="n">birth_gdf</span>
<span class="n">gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">]</span>      <span class="o">=</span> <span class="n">gdf</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">lat_lng_to_h3</span><span class="p">,</span> <span class="n">h3_level</span><span class="o">=</span><span class="n">h3_level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">hexagon</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">add_geometry</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">hex_only</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[[</span><span class="sh">'</span><span class="s">hexagon</span><span class="sh">'</span><span class="p">,</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">]].</span><span class="nf">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">)</span>
<span class="n">hex_only</span> <span class="o">=</span> <span class="n">gpd</span><span class="p">.</span><span class="nc">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">hexagon</span><span class="sh">'</span><span class="p">],</span> <span class="n">data</span><span class="o">=</span><span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">])</span>
<span class="n">hex_only</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">h3_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="n">code</span><span class="p">:</span> <span class="n">integer</span> <span class="k">for</span> <span class="n">integer</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">].</span><span class="nf">unique</span><span class="p">()))}</span>
<span class="n">gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">h3_int</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="sh">'</span><span class="s">h3</span><span class="sh">'</span><span class="p">].</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">h3_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="nf">print</span><span class="p">(</span><span class="n">hex_only</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1703, 2)
</code></pre></div></div> <p>Under our model, each of the H3 cells is assumed to have its own free parameter for the probability of preterm birth. However, we will use the CAR prior to allow for pooling information across spatial cells and encouraging spatial smoothness in their estimates.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">hex_only</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">edgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">H3 spatial cells</span><span class="sh">'</span><span class="p">)</span>
<span class="n">tract_gdf</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">edgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">DC census tracts</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">tight_layout</span><span class="p">()</span>
</code></pre></div></div> <p><img src="/images/preterm26_0.png" alt="png" style="width:75%;"></p> <p>As a final preprocessing step, we need to create the adjacency matrix \(W\) and ensure that every node has a path through the adjacency matrix to every other path. Put more formally, we need to ensure there is only a single connected component in \(W\) and that it is nontrivial.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In geographic coordinate system
</span><span class="n">very_small_distance</span> <span class="o">=</span> <span class="mf">0.0003</span>
<span class="n">W</span> <span class="o">=</span> <span class="nf">adjacency_via_buffer</span><span class="p">(</span><span class="n">hex_only</span><span class="p">,</span> <span class="n">very_small_distance</span><span class="o">=</span><span class="n">very_small_distance</span><span class="p">)</span>
<span class="n">W</span> <span class="o">=</span> <span class="nf">connect_components</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">hex_only</span><span class="p">)</span>
</code></pre></div></div> <p>To check the correctness of our procedures, we can make sure that every cell has at least neighbor and that no cell has more than six neighbors</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">neighbors_per_cell</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">neighbors_per_cell</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="n">neighbors_per_cell</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">6</span>
</code></pre></div></div> <h2 id="inference-for-model-parameters">Inference for model parameters</h2> <p>The probabilistic model we use has the following specification:</p> \[\alpha \sim Uniform(-0.95, 0.95)\\ c \sim Normal^{+}(0, 4)\\ \beta_0 \sim Normal(0, 9)\\ \mathbf{u}\sim CAR(W, \alpha)\\ y_j \sim Binomial(n_j, \sigma(u_j + \beta_0))\] <p>Here, \(Normal^{+}\) refers to the half-normal distribution with a mode at zero and almost all probability mass placed on the positive real line. Then, the CAR prior assumes that \(\mathbf{u}\) has a multivariate normal distribution with a spatially-smoothed covariance matrix. The spatial smoothing is informed by the cellwise adjacency matrix \(W\) and the spatial correlation parameter \(\alpha\). Finally, the number of preterm births within the \(i\)-th spatial cell is assumed to follow a binomial distribution with its logit specified as the spatial effect plus an intercept.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">preterm_counts</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="sh">'</span><span class="s">h3_int</span><span class="sh">'</span><span class="p">)[</span><span class="sh">'</span><span class="s">preterm</span><span class="sh">'</span><span class="p">].</span><span class="nf">sum</span><span class="p">()</span>
<span class="n">total_counts</span>   <span class="o">=</span> <span class="n">gdf</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="sh">'</span><span class="s">h3_int</span><span class="sh">'</span><span class="p">)[</span><span class="sh">'</span><span class="s">preterm</span><span class="sh">'</span><span class="p">].</span><span class="nf">count</span><span class="p">()</span>

<span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">preterm_counts</span><span class="p">)</span>

<span class="k">with</span> <span class="n">pm</span><span class="p">.</span><span class="nc">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model</span><span class="p">:</span>
    <span class="c1"># Hyperparameters on spatial correlation, random effect size, and model intercept
</span>    <span class="n">alpha</span>       <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nc">Uniform</span><span class="p">(</span><span class="sh">'</span><span class="s">alpha</span><span class="sh">'</span><span class="p">,</span><span class="n">lower</span><span class="o">=-</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>
    <span class="n">scale</span>       <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nc">HalfNormal</span><span class="p">(</span><span class="sh">'</span><span class="s">scale</span><span class="sh">'</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">intercept</span>   <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nc">Normal</span><span class="p">(</span><span class="sh">'</span><span class="s">intercept</span><span class="sh">'</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># Spatially-smoothing prior on logit of preterm birth probability
</span>    <span class="n">spatial_effect</span> <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nc">CAR</span><span class="p">(</span><span class="sh">'</span><span class="s">spatial_effect</span><span class="sh">'</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="n">likelihood</span>  <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nc">Binomial</span><span class="p">(</span><span class="sh">'</span><span class="s">likelihood</span><span class="sh">'</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">pm</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">sigmoid</span><span class="p">(</span><span class="n">spatial_effect</span><span class="o">*</span><span class="n">scale</span> <span class="o">+</span> <span class="n">intercept</span><span class="p">),</span>
                             <span class="n">observed</span><span class="o">=</span><span class="n">preterm_counts</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">total_counts</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>
    
    <span class="c1"># Applies Markov chain Monte Carlo to draw from the posterior distribution
</span>    <span class="n">trace</span> <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="nf">sample</span><span class="p">(</span><span class="n">target_accept</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">tune</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;&lt;!! BUG IN FGRAPH.REPLACE OR A LISTENER !!&gt;&gt; &lt;class 'TypeError'&gt; Cannot convert Type TensorType(float64, matrix) (of Variable Usmm{no_inplace}.0) into Type TensorType(float64, row). You can try to manually convert Usmm{no_inplace}.0 into a TensorType(float64, row). Elemwise{sub,no_inplace}(z, Elemwise{mul,no_inplace}(alpha subject to &lt;function &lt;lambda&gt; at 0x7f5e61173c10&gt;, SparseDot(x, y))) -&gt; Usmm{no_inplace}(Elemwise{neg,no_inplace}(alpha), x, y, z)
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [spatial_effect, intercept, scale, alpha]
</code></pre></div></div> <div> <style>progress{border:0;background-size:auto}.progress-bar-interrupted,.progress-bar-interrupted::-webkit-progress-bar{background:#f44336}</style> <progress value="12000" class="" max="12000" style="width:300px; height:20px; vertical-align: middle;"></progress> 100.00% [12000/12000 02:01&lt;00:00 Sampling 4 chains, 0 divergences] </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sampling 4 chains for 2_000 tune and 1_000 draw iterations (8_000 + 4_000 draws total) took 122 seconds.
The number of effective samples is smaller than 10% for some parameters.
</code></pre></div></div> <p>Our posterior summary, as reported below, indicates strong evidence for spatial autocorrelation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">model</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">pm</span><span class="p">.</span><span class="nf">summary</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">scale</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">alpha</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">intercept</span><span class="sh">'</span><span class="p">]))</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            mean     sd  hdi_3%  hdi_97%  mcse_mean  mcse_sd  ess_bulk  \
scale      0.483  0.036   0.411    0.547      0.001    0.001    1307.0   
alpha      0.947  0.003   0.943    0.950      0.000    0.000    3294.0   
intercept -1.983  0.026  -2.033   -1.936      0.001    0.001     363.0   

           ess_tail  r_hat  
scale        1876.0   1.00  
alpha        1618.0   1.00  
intercept     701.0   1.01  
</code></pre></div></div> <p>Our trace plots look good - no multimodality and the samples look uncorrelated. While the posterior for \(\alpha\) is piling up near the edge of the boundary, this is fine.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">model</span><span class="p">:</span>
    <span class="n">pm</span><span class="p">.</span><span class="nf">plot_trace</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">scale</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">alpha</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">intercept</span><span class="sh">'</span><span class="p">])</span>
</code></pre></div></div> <p><img src="/images/preterm37_0.png" alt="png" style="width:75%;"></p> <p>We next generate two plots to visualize the resulting estimates.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sigma_cutoff</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">estimated_intercept</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="sh">'</span><span class="s">intercept</span><span class="sh">'</span><span class="p">].</span><span class="nf">mean</span><span class="p">()</span>

<span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">preterm_fraction</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">preterm_counts</span> <span class="o">/</span> <span class="n">total_counts</span><span class="p">).</span><span class="n">values</span>
<span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">estimate</span><span class="sh">'</span><span class="p">]</span>   <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="sh">'</span><span class="s">spatial_effect</span><span class="sh">'</span><span class="p">].</span><span class="nf">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">stdevs</span><span class="sh">'</span><span class="p">]</span>     <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="sh">'</span><span class="s">spatial_effect</span><span class="sh">'</span><span class="p">].</span><span class="nf">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">trace</span><span class="p">[</span><span class="sh">'</span><span class="s">spatial_effect</span><span class="sh">'</span><span class="p">].</span><span class="nf">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">is_sig</span><span class="sh">'</span><span class="p">]</span>     <span class="o">=</span> <span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">stdevs</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">sigma_cutoff</span>
<span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">delta_prob</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">hex_only</span><span class="p">[</span><span class="sh">'</span><span class="s">estimate</span><span class="sh">'</span><span class="p">]</span><span class="o">+</span><span class="n">estimated_intercept</span><span class="p">)</span> <span class="o">-</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">estimated_intercept</span><span class="p">)</span>
</code></pre></div></div> <p>First, we create a plot of the data - the observed ratios of preterm births on a cell-by-cell basis.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">hex_only</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="sh">'</span><span class="s">preterm_fraction</span><span class="sh">'</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="n">handle</span> <span class="o">=</span> <span class="n">tract_gdf</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">);</span>

<span class="n">row_ctr</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">hex_only</span><span class="p">.</span><span class="nf">iterrows</span><span class="p">():</span>
    <span class="n">cent</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">geometry</span><span class="sh">'</span><span class="p">].</span><span class="n">centroid</span> 
    <span class="n">ax</span><span class="p">.</span><span class="nf">text</span><span class="p">(</span><span class="n">cent</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cent</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">preterm_counts</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_ctr</span><span class="p">]</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total_counts</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_ctr</span><span class="p">]</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span>
                 <span class="n">ha</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="sh">'</span><span class="s">bold</span><span class="sh">'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">row_ctr</span> <span class="o">+=</span> <span class="mi">1</span>
    

</code></pre></div></div> <p><img src="/images/preterm41_0.png" alt="png" style="width:75%;"></p> <p>Next, we compare against our inferred estimates. Cells for which our estimate of the spatial effect is significant at the \(2\sigma\) level are highlighted with a star.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ax</span> <span class="o">=</span> <span class="n">hex_only</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="sh">'</span><span class="s">estimate</span><span class="sh">'</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">))</span>
<span class="n">tract_gdf</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">none</span><span class="sh">'</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">hex_only</span><span class="p">.</span><span class="nf">iterrows</span><span class="p">():</span>
    <span class="n">cent</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">geometry</span><span class="sh">'</span><span class="p">].</span><span class="n">centroid</span> 
    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">is_sig</span><span class="sh">'</span><span class="p">]:</span>
        <span class="n">sig_str</span> <span class="o">=</span> <span class="sh">'</span><span class="s">*</span><span class="sh">'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sig_str</span> <span class="o">=</span> <span class="sh">''</span>
    <span class="n">se</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="sh">'</span><span class="s">delta_prob</span><span class="sh">'</span><span class="p">]</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">text</span><span class="p">(</span><span class="n">cent</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">cent</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sig_str</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">,</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="sh">'</span><span class="s">bold</span><span class="sh">'</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Simulated preterm birth ratio</span><span class="sh">'</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Inferred change in probability of preterm birth</span><span class="sh">'</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">);</span>
</code></pre></div></div> <p><img src="/images/preterm43_0.png" alt="png" style="width:75%;"></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/creating-an-emulator-for-an-agent-based-model/">Surrogate modeling for SEIR dynamics</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/nonparametric-changepoint-model-pymc/">Modeling temporal data with an unknown number of changepoints</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/density-estimation-for-geospatial-imagery-using-autoregressive-models/">Density estimation for geospatial imagery using autoregressive neural models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/why-dont-we-just-freeze-the-carbon/">Solving climate change by abusing thermodynamic scaling laws</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/balanced-spatial-partitioning-for-point-data-in-20-lines/">Balanced spatial partitioning for point data in 20 lines</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Christopher Krapu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js" integrity="sha256-YyRhy+F3bG+zvvwsW1E/uy5s5pKXwmG/bOPlV+1pt6o=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let theme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===theme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=document.querySelector(".navbar-collapse");e.classList.contains("show")&&e.classList.remove("show"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-posts",title:"posts",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-solving-climate-change-by-abusing-thermodynamic-scaling-laws",title:"Solving climate change by abusing thermodynamic scaling laws",description:"A wintertime climate change solution",section:"Posts",handler:()=>{window.location.href="/blog/2024/why-dont-we-just-freeze-the-carbon/"}},{id:"post-modeling-temporal-data-with-an-unknown-number-of-changepoints",title:"Modeling temporal data with an unknown number of changepoints",description:"A nonparametric changepoint model in PyMC",section:"Posts",handler:()=>{window.location.href="/blog/2022/nonparametric-changepoint-model-pymc/"}},{id:"post-distributed-zonal-averages-for-fast-geospatial-analyses",title:"Distributed zonal averages for fast geospatial analyses",description:"Easy local average with Google Earth Engine&#39;s Python API",section:"Posts",handler:()=>{window.location.href="/blog/2022/fast-local-summary-earth-engine/"}},{id:"post-fast-kronecker-matrix-vector-product-with-einsum",title:"Fast Kronecker matrix-vector product with einsum",description:"Easy local average with Google Earth Engine&#39;s Python API",section:"Posts",handler:()=>{window.location.href="/blog/2021/fast-matrix-vector-product-for-structured-matrices/"}},{id:"post-balanced-spatial-partitioning-for-point-data-in-20-lines",title:"Balanced spatial partitioning for point data in 20 lines",description:"Recursively splitting by boxes",section:"Posts",handler:()=>{window.location.href="/blog/2021/balanced-spatial-partitioning-for-point-data-in-20-lines/"}},{id:"post-modeling-spatial-structure-in-binary-data-with-an-h3-hexagonal-coordinate-system",title:"Modeling spatial structure in binary data with an H3 hexagonal coordinate system",description:"Conditional autoregression for 6-adjacent data",section:"Posts",handler:()=>{window.location.href="/blog/2021/clustering-for-prob-preterm-birth/"}},{id:"post-surrogate-modeling-for-seir-dynamics",title:"Surrogate modeling for SEIR dynamics",description:"Modeling a model, for epidemiology",section:"Posts",handler:()=>{window.location.href="/blog/2021/creating-an-emulator-for-an-agent-based-model/"}},{id:"post-density-estimation-for-geospatial-imagery-using-autoregressive-neural-models",title:"Density estimation for geospatial imagery using autoregressive neural models",description:"Conditional autoregression for 6-adjacent data",section:"Posts",handler:()=>{window.location.href="/blog/2020/density-estimation-for-geospatial-imagery-using-autoregressive-models/"}},{id:"post-multivariate-sample-size-for-markov-chains",title:"Multivariate sample size for Markov chains",description:"Assessing effective sample size for multiple variates",section:"Posts",handler:()=>{window.location.href="/blog/2020/multivariate-sample-size-for-markov-chains/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%63%6B%72%61%70%75@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-github",title:"GitHub",section:"Socials",handler:()=>{window.open("https://github.com/ckrapu","_blank")}},{id:"socials-rss",title:"RSS Feed",section:"Socials",handler:()=>{window.open("/feed.xml","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> </body> </html>